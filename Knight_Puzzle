class KnightsTourPuzzle:
    def __init__(self, x, y):
        self.mat_x_dim = x
        self.mat_y_dim = y
        self.dimension = self.mat_x_dim * self.mat_y_dim
        self.empty_sqr = len(str(self.dimension)) * "_"
        self.occupied_position = (len(str(self.dimension)) - 1) * ' ' + "X"
        self.sqr_length = len(self.empty_sqr)
        self.field = [[self.empty_sqr for _ in range(self.mat_x_dim)] for _ in range(self.mat_y_dim)]


    def field_print(self):
        """Prints game field."""
        max_length = len((str(self.mat_y_dim) + '| ' + ' '.join(self.field[-1]) + ' |'))
        border = ((self.mat_x_dim * (self.sqr_length + 1) + 3) * "-")
        print(border.rjust(max_length))
        for i in range(self.mat_y_dim, 0, -1):
            print((str(i) + '| ' + ' '.join(self.field[i - 1]) + ' |').rjust(max_length))
        print(border.rjust(max_length))
        print(" ".join(str(i).rjust(self.sqr_length) for i in range(1, self.mat_x_dim + 1)).rjust(max_length - 2))

    @staticmethod
    def input_dimensions():
        """
        Subprogram that take user input and checks it,according to properties:
        If the board's dimensions contain non-integer numbers print Invalid dimensions!.
        If the board's dimensions contain more than 2 numbers print Invalid dimensions!.
        If the board's dimensions contain negative numbers print Invalid dimensions!.
        If invalid dimensions were provided by the user, ask them for valid dimensions again after outputting Invalid dimensions!
        """
        while True:
            try:
                f_row, f_col = [int(i) for i in input("Enter your board dimensions:").split()]
                if f_row < 0 or f_col < 0:
                    raise ValueError
                else:
                    return f_row, f_col
            except ValueError:
                print("Invalid dimensions")

    def input_position(self):
        """
        Subprogram that take user input and checks it,according to properties:
        If the user input contains non-integer numbers you should print Invalid position!.
        If the user input contains more than 2 numbers you should print Invalid position!.
        If the user input numbers out of bounds of the game field you should print Invalid position!.
        """
        while True:
            try:
                x, y = [int(i) for i in input("Enter the knight's starting position:").split()]
                if not all((1 <= x <= self.mat_x_dim, 1 <= y <= self.mat_y_dim)):
                    raise ValueError
                else:
                    return x - 1, y - 1
            except ValueError:
                print("Invalid position!")

    def make_move(self, x, y):
        self.field[y][x] = self.occupied_position

    def possible_moves_calc(self, x, y):
        all_possible_moves = [[x - 2, y + 1],
                              [x - 2, y - 1],
                              [x + 2, y - 1],
                              [x + 2, y + 1],
                              [x - 1, y + 2],
                              [x + 1, y + 2],
                              [x - 1, y - 2],
                              [x + 1, y - 2]]

        possible_moves = []
        for move in all_possible_moves:
            if 0 <= move[0] < self.mat_x_dim and 0 <= move[1] < self.mat_y_dim:
                possible_moves.append(tuple(move))
        return possible_moves

    def pos_moves_position(self, moves: list):
        coord_dict = {}
        for move in moves:
            coord_dict[move] = self.possible_moves_calc(move[0], move[1])

        for move, moves_lst in coord_dict.items():
            possible_move = str(len(moves_lst) - 1).rjust(len(self.field[0][0]))
            x = move[0]
            y = move[1]
            self.field[y][x] = possible_move

    def pos_moves_print(self):
        print("\nHere are the possible moves:")
        self.field_print()


if __name__ == '__main__':
    a, b = KnightsTourPuzzle.input_dimensions()
    new_game = KnightsTourPuzzle(a, b)
    move_x, move_y = new_game.input_position()
    new_game.make_move(move_x, move_y)
    pos_moves_lst = new_game.possible_moves_calc(move_x, move_y)
    new_game.pos_moves_position(pos_moves_lst)
    new_game.pos_moves_print()
